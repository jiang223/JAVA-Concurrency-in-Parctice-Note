# 5.5同步工具类

## 1、闭锁

闭锁是一种同步工具类可以延迟线程的进度直到其到达种植状态。闭锁的作用相当于一扇门：闭锁到达结束状态前，这扇门一直是关闭的。并且没有任何线程能通过，当到达结束状态时，这扇门就会打开并一直允许任何线程通过，当门打开后且不会再次关闭。闭锁的使用

* 确保某个计算在资源都初始化完成后执行
* 确保某个服务在其依赖的其它服务都启动完成后再启动
* 等待直到某个操作的所有参与者都就绪后开始执行

CountDownLatch是一种灵活的闭锁实现，可以在上述情况中使用。countDown方法递减计数器，表示有一个事件发生了。而await方法等待计数器达到零，如果计数器非零，那么await会一直阻塞直到计数器清零为止。



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * TestHarness
 * <p/>
 * Using CountDownLatch for starting and stopping threads in timing tests
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {
                    }
                }
            };
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

通过使用两个闭锁，分别表示线程开始以及线程结束，通过获取两个时间，来准确计算所有线程任务的总耗时。

启动门startGate将使得主线程能够同时释放所有的工作线程。



FutureTask也可以用作闭锁。



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * Preloader
 *
 * Using FutureTask to preload data that is needed later
 *
 * @author Brian Goetz and Tim Peierls
 */

public class Preloader {
    ProductInfo loadProductInfo() throws DataLoadException {
        return null;
    }

    private final FutureTask<ProductInfo> future =
        new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException)
                throw (DataLoadException) cause;
            else
                throw LaunderThrowable.launderThrowable(cause);
        }
    }

    interface ProductInfo {
    }
}

class DataLoadException extends Exception { }
```

##
